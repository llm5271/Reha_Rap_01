/*****************************************************************************
   can_CAN3.c
   Generated By:
   Raptor 2021b_1.0.14409 (6115)
   Matlab (R2021b) 9.11

   Copyright (c) 2018 New Eagle Products, Inc.
   All rights reserved.

   Code Generated at: Sat Sep 10 17:18:14 2022
 *****************************************************************************/

/*  CAN Bus : CAN3 	*/
/*  Resource: CAN3 	*/
/*  Bus Enum: CAN_BUS_C */
/* Baud Rate: 250k 	*/
#include "core_env.h"
#include "sws_can.h"
#include "Reha_Rap01.h"
#include "can_general.h"
#include "can_CAN3.h"
#include "codegen_hwe_cpu.h"
#include "e_rtatr.h"
#include "cpu_pub.h"
#define MAX_AGE                        65535

/* Message Recieve data storage */

/* Transmit CAN Object Declarations */
uint16_T can_CAN3_startupDelay = 500;

#define RX_MSG_ENTRY_START             12
#define CAN_TX_QUEUE_SIZE              16
#define START_SECTION_volatile_SlowRam_oem_32bit
#include "swsh_rb2oem.h"

uint8_T txData_CAN3[CAN_TX_QUEUE_SIZE][8];
uint32_T txID_CAN3[CAN_TX_QUEUE_SIZE];
uint8_T txExt_CAN3[CAN_TX_QUEUE_SIZE];
uint8_T txLen_CAN3[CAN_TX_QUEUE_SIZE];

#define STOP_SECTION_volatile_SlowRam_oem_32bit
#include "swsh_rb2oem.h"

uint8_T txQHead_CAN3 = 0;
uint8_T txQTail_CAN3 = 0;

/* Functions */
void pre_start_CAN_CAN3(void)
{
  memset((void *)&txData_CAN3, 0, sizeof(txData_CAN3));
  memset((void *)&txID_CAN3, 0, sizeof(txID_CAN3));
  can_CAN3_startupDelay = CAN3_Startup_Delay_Data();
  if (can_CAN3_startupDelay < 20) {
    can_CAN3_startupDelay = 20;
  }
}

void post_start_CAN_CAN3(void)
{
  uint8 i = 0;
  swsh_ChangeBaudRate_ini( CAN_BUS_C, CAN_250K_BAUD );
  for (i=8;i<12;i++) {
    canMsgInfo[i].MessageId = 0xF0000000;
    canMsgBuffInUse[i] = 0;
  }
}

void CAN3_TX_Queue_Get_Status(uint8_T* queueSize, uint8_T* depth, uint8_T
  * maxDepth, uint32_T* overruns )
{
  *queueSize = CAN_TX_QUEUE_SIZE;
  *depth = CAN3_CANTX_QueueCount_Data();
  *maxDepth = CAN3_CANTX_QueueMax_Data();
  *overruns = CAN3_CANTX_QueueOverrun_Data();
}

void can_update_CAN3(uint32_T id, uint8_T extended, uint8_T length, const
                     uint8_T *data)
{
  uint8_T i;
  uint32_T id_masked = id;
  if (extended) {
    id_masked &= 0x1fffffff;
  } else {
    id_masked = (id_masked >= 0x7ff) ? 0x7ff : (id_masked & 0x7ff);
  }

  SuspInt();
  if (CAN3_CANTX_QueueCount_Data() < CAN_TX_QUEUE_SIZE) {
    txID_CAN3[txQHead_CAN3] = id_masked;
    txExt_CAN3[txQHead_CAN3] = extended;
    txLen_CAN3[txQHead_CAN3] = length;
    for (i = 0; i < length; i++) {
      txData_CAN3[txQHead_CAN3][i] = data[i];
    }

    txQHead_CAN3 = (txQHead_CAN3 + 1) % CAN_TX_QUEUE_SIZE;
    CAN3_CANTX_QueueCount_Data()++;
    if ((CAN3_CANTX_QueueCount_Data()+1) > CAN3_CANTX_QueueMax_Data()) {
      CAN3_CANTX_QueueMax_Data() = CAN3_CANTX_QueueCount_Data()+1;
    }
  } else {
    if (CAN3_CANTX_QueueOverrun_Data() < 255) {
      CAN3_CANTX_QueueOverrun_Data() = CAN3_CANTX_QueueOverrun_Data() + 1;
    }
  }

  ResInt();
}

/**********  Transmit Messages *****************/
void can_update_tx_ID_CAN3(uint8 bufToUse, uint32_T id, uint8_T extended)
{
  uint8_T initRequired = 0;
  if (extended) {
    if (canMsgInfo[bufToUse].MessageId != id) {
      canMsgInfo[bufToUse].MessageId = id;
      initRequired = 1;
    }

    canMsgBuffInUse[bufToUse] = 1;
  } else {
    if (canMsgInfo[bufToUse+1].MessageId != id) {
      canMsgInfo[bufToUse+1].MessageId = id;
      initRequired = 1;
    }

    canMsgBuffInUse[bufToUse+1] = 1;
  }

  if (initRequired) {
    swsh_caninit_user(0, &can_init[0]);
  }
}

boolean can_IsSendable_tx_ID_CAN3(uint8_T bufToUse, uint32_T id, uint8_T
  extended)
{
  uint8 i = 0;

  //is the desired buffer available?
  if (extended) {
    if (canMsgBuffInUse[bufToUse]) {
      return 0;
    }
  } else {
    if (canMsgBuffInUse[bufToUse+1]) {
      return 0;
    }
  }

  //is a transmit for this ID already pending?
  for (i=0;i< 12;i++) {
    if (canMsgBuffInUse[i]
        && canMsgInfo[i].MessageId == id
        && canMsgInfo[i].MessageFormat == extended) {
      return 0;
    }
  }

  return 1;
}

/* Must be called with Interrupts Enabled */
void can_process_tx_queues_CAN3_i(void)
{
  static uint8 nextBuffer = 0;
  uint32 id = 0;
  uint8* data = 0;
  uint8 length = 0;
  uint8 extended = 0;
  uint8 bufNum = 0;
  if (!can_CAN3_startupDelay) {
    if (CAN3_CANTX_QueueCount_Data() > 0) {
      id = txID_CAN3[txQTail_CAN3];
      data = &txData_CAN3[txQTail_CAN3][0];
      length = txLen_CAN3[txQTail_CAN3];
      extended = txExt_CAN3[txQTail_CAN3];
      bufNum = 8+(nextBuffer*2);
      if (can_IsSendable_tx_ID_CAN3(bufNum, id, extended)) {
        txQTail_CAN3 = (txQTail_CAN3+1) % CAN_TX_QUEUE_SIZE;
        CAN3_CANTX_QueueCount_Data()--;
        nextBuffer = (nextBuffer < 1) ? 1 : 0;
        can_update_tx_ID_CAN3(bufNum, id, extended);
        swsh_cantx_user(CAN_BUS_C, id, data, length, extended);
      }
    }
  }
}

void can_process_tx_queues_CAN3(void)
{
  SuspInt();
  can_process_tx_queues_CAN3_i();
  ResInt();
}

void CANTx_Buffer9(uint16 msgHandle_u16,uint32 *msgId_pu32,uint8 *msgDlc_pu8,
                   uint8 *msgData_pu8)
{
  UNUSED(msgHandle_u16);
  UNUSED(msgId_pu32);
  UNUSED(msgDlc_pu8);
  UNUSED(msgData_pu8);
  canMsgInfo[8].MessageId = 0xF0000000;
  canMsgBuffInUse[8] = 0;
  can_process_tx_queues_CAN3();
}

void CANTx_Buffer10(uint16 msgHandle_u16,uint32 *msgId_pu32,uint8 *msgDlc_pu8,
                    uint8 *msgData_pu8)
{
  UNUSED(msgHandle_u16);
  UNUSED(msgId_pu32);
  UNUSED(msgDlc_pu8);
  UNUSED(msgData_pu8);
  canMsgInfo[9].MessageId = 0xF0000000;
  canMsgBuffInUse[9] = 0;
  can_process_tx_queues_CAN3();
}

void CANTx_Buffer11(uint16 msgHandle_u16,uint32 *msgId_pu32,uint8 *msgDlc_pu8,
                    uint8 *msgData_pu8)
{
  UNUSED(msgHandle_u16);
  UNUSED(msgId_pu32);
  UNUSED(msgDlc_pu8);
  UNUSED(msgData_pu8);
  canMsgInfo[10].MessageId = 0xF0000000;
  canMsgBuffInUse[10] = 0;
  can_process_tx_queues_CAN3();
}

void CANTx_Buffer12(uint16 msgHandle_u16,uint32 *msgId_pu32,uint8 *msgDlc_pu8,
                    uint8 *msgData_pu8)
{
  UNUSED(msgHandle_u16);
  UNUSED(msgId_pu32);
  UNUSED(msgDlc_pu8);
  UNUSED(msgData_pu8);
  canMsgInfo[11].MessageId = 0xF0000000;
  canMsgBuffInUse[11] = 0;
  can_process_tx_queues_CAN3();
}

void can_process_CAN3(void)
{
  static uint8 can_errorCheck_CAN3_count = 0;
  can_CAN3_startupDelay = (can_CAN3_startupDelay > 0) ? can_CAN3_startupDelay-1 :
    0;
  can_process_tx_queues_CAN3();
  if ((CAN3_ErrorCheck_Interval_Data() > 0) && (can_errorCheck_CAN3_count++ >
       CAN3_ErrorCheck_Interval_Data())) {
    can_errorCheck_CAN3_count = 0;
    can_errorCheck_CAN3();
  }
}

void can_errorCheck_CAN3(void)
{
  if (!can_CAN3_startupDelay) {
    uint16_T canStatus = Can_GetNodeStatus(CAN_BUS_C);
    if (canStatus & 0x01)              /* Bus Off */
    {
      /* Reinitialize the CAN driver */
      Can_InitNode(CAN_BUS_C);
      swsh_ChangeBaudRate_ini( CAN_BUS_C, CAN_250K_BAUD );
    } else if (canStatus & 0x800) {
      Can_InitNode(CAN_BUS_C);
      swsh_ChangeBaudRate_ini( CAN_BUS_C, CAN_250K_BAUD );
      can_CAN3_startupDelay = CAN3_ErrorPassive_Delay_Data();
    }

    if (canStatus > 0)                 /* Error */
    {
      uint8_T i;
      SuspInt();
      can_CAN3_startupDelay += 5;
      for (i=0;i<4;i++) {
        canMsgBuffInUse[8+i] = 0;
        canMsgInfo[8+i].MessageId = 0xF0000000;
      }

      ResInt();
    }
  }
}

void CAN_NewEagle_Receive_MSG_STD_Node3(uint16 msgHandle_u16, uint32 *msgId_pu32,
  uint8 *msgDlc_pu8, uint8 *msgData_pu8)
{
  extern uint8 app_is_in_shutdown;
  MessageData data;
  uint32 id = *msgId_pu32;
  data.message_id = id;
  data.parameter1 = *msgDlc_pu8;
  data.parameter2 = msgData_pu8;
  UNUSED(msgHandle_u16);

  /* Standard Receive Table */
}

void CAN_NewEagle_Receive_MSG_EXD_Node3(uint16 msgHandle_u16,uint32 *msgId_pu32,
  uint8 *msgDlc_pu8, uint8 *msgData_pu8)
{
  extern uint8 app_is_in_shutdown;
  MessageData data;
  uint32 id = *msgId_pu32;
  data.message_id = id;
  data.parameter1 = *msgDlc_pu8;
  data.parameter2 = msgData_pu8;
  UNUSED(msgHandle_u16);

  /* Extended Receive Table */
}
