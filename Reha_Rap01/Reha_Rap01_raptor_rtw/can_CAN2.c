/*****************************************************************************
   can_CAN2.c
   Generated By:
   Raptor 2021b_1.0.14409 (6115)
   Matlab (R2021b) 9.11

   Copyright (c) 2018 New Eagle Products, Inc.
   All rights reserved.

   Code Generated at: Sat Sep 10 17:18:14 2022
 *****************************************************************************/

/*  CAN Bus : CAN2 	*/
/*  Resource: CAN2 	*/
/*  Bus Enum: CAN_BUS_B */
/* Baud Rate: 500k 	*/
#include "core_env.h"
#include "sws_can.h"
#include "Reha_Rap01.h"
#include "can_general.h"
#include "can_CAN2.h"
#include "codegen_hwe_cpu.h"
#include "e_rtatr.h"
#include "cpu_pub.h"
#define MAX_AGE                        65535

/* Message Recieve data storage */

/* Transmit CAN Object Declarations */
uint16_T can_CAN2_startupDelay = 500;

#define RX_MSG_ENTRY_START             12
#define CAN_TX_QUEUE_SIZE              16
#define START_SECTION_volatile_SlowRam_oem_32bit
#include "swsh_rb2oem.h"

uint8_T txData_CAN2[CAN_TX_QUEUE_SIZE][8];
uint32_T txID_CAN2[CAN_TX_QUEUE_SIZE];
uint8_T txExt_CAN2[CAN_TX_QUEUE_SIZE];
uint8_T txLen_CAN2[CAN_TX_QUEUE_SIZE];

#define STOP_SECTION_volatile_SlowRam_oem_32bit
#include "swsh_rb2oem.h"

uint8_T txQHead_CAN2 = 0;
uint8_T txQTail_CAN2 = 0;

/* Functions */
void pre_start_CAN_CAN2(void)
{
  memset((void *)&txData_CAN2, 0, sizeof(txData_CAN2));
  memset((void *)&txID_CAN2, 0, sizeof(txID_CAN2));
  can_CAN2_startupDelay = CAN2_Startup_Delay_Data();
  if (can_CAN2_startupDelay < 20) {
    can_CAN2_startupDelay = 20;
  }
}

void post_start_CAN_CAN2(void)
{
  uint8 i = 0;
  swsh_ChangeBaudRate_ini( CAN_BUS_B, CAN_500K_BAUD );
  for (i=4;i<8;i++) {
    canMsgInfo[i].MessageId = 0xF0000000;
    canMsgBuffInUse[i] = 0;
  }
}

void CAN2_TX_Queue_Get_Status(uint8_T* queueSize, uint8_T* depth, uint8_T
  * maxDepth, uint32_T* overruns )
{
  *queueSize = CAN_TX_QUEUE_SIZE;
  *depth = CAN2_CANTX_QueueCount_Data();
  *maxDepth = CAN2_CANTX_QueueMax_Data();
  *overruns = CAN2_CANTX_QueueOverrun_Data();
}

void can_update_CAN2(uint32_T id, uint8_T extended, uint8_T length, const
                     uint8_T *data)
{
  uint8_T i;
  uint32_T id_masked = id;
  if (extended) {
    id_masked &= 0x1fffffff;
  } else {
    id_masked = (id_masked >= 0x7ff) ? 0x7ff : (id_masked & 0x7ff);
  }

  SuspInt();
  if (CAN2_CANTX_QueueCount_Data() < CAN_TX_QUEUE_SIZE) {
    txID_CAN2[txQHead_CAN2] = id_masked;
    txExt_CAN2[txQHead_CAN2] = extended;
    txLen_CAN2[txQHead_CAN2] = length;
    for (i = 0; i < length; i++) {
      txData_CAN2[txQHead_CAN2][i] = data[i];
    }

    txQHead_CAN2 = (txQHead_CAN2 + 1) % CAN_TX_QUEUE_SIZE;
    CAN2_CANTX_QueueCount_Data()++;
    if ((CAN2_CANTX_QueueCount_Data()+1) > CAN2_CANTX_QueueMax_Data()) {
      CAN2_CANTX_QueueMax_Data() = CAN2_CANTX_QueueCount_Data()+1;
    }
  } else {
    if (CAN2_CANTX_QueueOverrun_Data() < 255) {
      CAN2_CANTX_QueueOverrun_Data() = CAN2_CANTX_QueueOverrun_Data() + 1;
    }
  }

  ResInt();
}

/**********  Transmit Messages *****************/
void can_update_tx_ID_CAN2(uint8 bufToUse, uint32_T id, uint8_T extended)
{
  uint8_T initRequired = 0;
  if (extended) {
    if (canMsgInfo[bufToUse].MessageId != id) {
      canMsgInfo[bufToUse].MessageId = id;
      initRequired = 1;
    }

    canMsgBuffInUse[bufToUse] = 1;
  } else {
    if (canMsgInfo[bufToUse+1].MessageId != id) {
      canMsgInfo[bufToUse+1].MessageId = id;
      initRequired = 1;
    }

    canMsgBuffInUse[bufToUse+1] = 1;
  }

  if (initRequired) {
    swsh_caninit_user(0, &can_init[0]);
  }
}

boolean can_IsSendable_tx_ID_CAN2(uint8_T bufToUse, uint32_T id, uint8_T
  extended)
{
  uint8 i = 0;

  //is the desired buffer available?
  if (extended) {
    if (canMsgBuffInUse[bufToUse]) {
      return 0;
    }
  } else {
    if (canMsgBuffInUse[bufToUse+1]) {
      return 0;
    }
  }

  //is a transmit for this ID already pending?
  for (i=0;i< 12;i++) {
    if (canMsgBuffInUse[i]
        && canMsgInfo[i].MessageId == id
        && canMsgInfo[i].MessageFormat == extended) {
      return 0;
    }
  }

  return 1;
}

/* Must be called with Interrupts Enabled */
void can_process_tx_queues_CAN2_i(void)
{
  static uint8 nextBuffer = 0;
  uint32 id = 0;
  uint8* data = 0;
  uint8 length = 0;
  uint8 extended = 0;
  uint8 bufNum = 0;
  if (!can_CAN2_startupDelay) {
    if (CAN2_CANTX_QueueCount_Data() > 0) {
      id = txID_CAN2[txQTail_CAN2];
      data = &txData_CAN2[txQTail_CAN2][0];
      length = txLen_CAN2[txQTail_CAN2];
      extended = txExt_CAN2[txQTail_CAN2];
      bufNum = 4+(nextBuffer*2);
      if (can_IsSendable_tx_ID_CAN2(bufNum, id, extended)) {
        txQTail_CAN2 = (txQTail_CAN2+1) % CAN_TX_QUEUE_SIZE;
        CAN2_CANTX_QueueCount_Data()--;
        nextBuffer = (nextBuffer < 1) ? 1 : 0;
        can_update_tx_ID_CAN2(bufNum, id, extended);
        swsh_cantx_user(CAN_BUS_B, id, data, length, extended);
      }
    }
  }
}

void can_process_tx_queues_CAN2(void)
{
  SuspInt();
  can_process_tx_queues_CAN2_i();
  ResInt();
}

void CANTx_Buffer5(uint16 msgHandle_u16,uint32 *msgId_pu32,uint8 *msgDlc_pu8,
                   uint8 *msgData_pu8)
{
  UNUSED(msgHandle_u16);
  UNUSED(msgId_pu32);
  UNUSED(msgDlc_pu8);
  UNUSED(msgData_pu8);
  canMsgInfo[4].MessageId = 0xF0000000;
  canMsgBuffInUse[4] = 0;
  can_process_tx_queues_CAN2();
}

void CANTx_Buffer6(uint16 msgHandle_u16,uint32 *msgId_pu32,uint8 *msgDlc_pu8,
                   uint8 *msgData_pu8)
{
  UNUSED(msgHandle_u16);
  UNUSED(msgId_pu32);
  UNUSED(msgDlc_pu8);
  UNUSED(msgData_pu8);
  canMsgInfo[5].MessageId = 0xF0000000;
  canMsgBuffInUse[5] = 0;
  can_process_tx_queues_CAN2();
}

void CANTx_Buffer7(uint16 msgHandle_u16,uint32 *msgId_pu32,uint8 *msgDlc_pu8,
                   uint8 *msgData_pu8)
{
  UNUSED(msgHandle_u16);
  UNUSED(msgId_pu32);
  UNUSED(msgDlc_pu8);
  UNUSED(msgData_pu8);
  canMsgInfo[6].MessageId = 0xF0000000;
  canMsgBuffInUse[6] = 0;
  can_process_tx_queues_CAN2();
}

void CANTx_Buffer8(uint16 msgHandle_u16,uint32 *msgId_pu32,uint8 *msgDlc_pu8,
                   uint8 *msgData_pu8)
{
  UNUSED(msgHandle_u16);
  UNUSED(msgId_pu32);
  UNUSED(msgDlc_pu8);
  UNUSED(msgData_pu8);
  canMsgInfo[7].MessageId = 0xF0000000;
  canMsgBuffInUse[7] = 0;
  can_process_tx_queues_CAN2();
}

void can_process_CAN2(void)
{
  static uint8 can_errorCheck_CAN2_count = 0;
  can_CAN2_startupDelay = (can_CAN2_startupDelay > 0) ? can_CAN2_startupDelay-1 :
    0;
  can_process_tx_queues_CAN2();
  if ((CAN2_ErrorCheck_Interval_Data() > 0) && (can_errorCheck_CAN2_count++ >
       CAN2_ErrorCheck_Interval_Data())) {
    can_errorCheck_CAN2_count = 0;
    can_errorCheck_CAN2();
  }
}

void can_errorCheck_CAN2(void)
{
  if (!can_CAN2_startupDelay) {
    uint16_T canStatus = Can_GetNodeStatus(CAN_BUS_B);
    if (canStatus & 0x01)              /* Bus Off */
    {
      /* Reinitialize the CAN driver */
      Can_InitNode(CAN_BUS_B);
      swsh_ChangeBaudRate_ini( CAN_BUS_B, CAN_500K_BAUD );
    } else if (canStatus & 0x800) {
      Can_InitNode(CAN_BUS_B);
      swsh_ChangeBaudRate_ini( CAN_BUS_B, CAN_500K_BAUD );
      can_CAN2_startupDelay = CAN2_ErrorPassive_Delay_Data();
    }

    if (canStatus > 0)                 /* Error */
    {
      uint8_T i;
      SuspInt();
      can_CAN2_startupDelay += 5;
      for (i=0;i<4;i++) {
        canMsgBuffInUse[4+i] = 0;
        canMsgInfo[4+i].MessageId = 0xF0000000;
      }

      ResInt();
    }
  }
}

void CAN_NewEagle_Receive_MSG_STD_Node2(uint16 msgHandle_u16, uint32 *msgId_pu32,
  uint8 *msgDlc_pu8, uint8 *msgData_pu8)
{
  extern uint8 app_is_in_shutdown;
  MessageData data;
  uint32 id = *msgId_pu32;
  data.message_id = id;
  data.parameter1 = *msgDlc_pu8;
  data.parameter2 = msgData_pu8;
  UNUSED(msgHandle_u16);

  /* Standard Receive Table */
}

void CAN_NewEagle_Receive_MSG_EXD_Node2(uint16 msgHandle_u16,uint32 *msgId_pu32,
  uint8 *msgDlc_pu8, uint8 *msgData_pu8)
{
  extern uint8 app_is_in_shutdown;
  MessageData data;
  uint32 id = *msgId_pu32;
  data.message_id = id;
  data.parameter1 = *msgDlc_pu8;
  data.parameter2 = msgData_pu8;
  UNUSED(msgHandle_u16);

  /* Extended Receive Table */
}
