/*****************************************************************************
   data.c
   Generated By:
   Raptor 2021b_1.0.14409 (6115)
   Matlab (R2021b) 9.11

   Copyright (c) 2018 New Eagle Products, Inc.
   All rights reserved.

   Code Generated at: Thu Sep  8 16:16:02 2022
 *****************************************************************************/

#include "raptor_types.h"
#include "data.h"
#include "string.h"                    /* TODO Reseach availabilty */
#include "Reha_Rap01.h"
#include "Reha_Rap01_private.h"

/* SS_DOUBLE  =  0,    / real32_T    /
   SS_SINGLE  =  1,    / real32_T  /
   SS_INT8    =  2,    / int8_T    /
   SS_UINT8   =  3,    / uint8_T   /
   SS_INT16   =  4,    / int16_T   /
   SS_UINT16  =  5,    / uint16_T  /
   SS_INT32   =  6,    / int32_T   /
   SS_UINT32  =  7,    / uint32_T  /
   SS_BOOLEAN =  8     / boolean_T */
#define START_SECTION_volatile_SlowRam_oem_32bit
#include "swsh_rb2oem.h"

RAMVariables_T RAMVariables ;

#define STOP_SECTION_volatile_SlowRam_oem_32bit
#include "swsh_rb2oem.h"
#define START_SECTION_Const_oem_32bit
#include "swsh_rb2oem.h"

const RAMVariables_T RAMVariables_DEFAULT = {
  55,                                  /*INIT_RAM_Variables*/
  0,                                   /* FgndTasksStopped */
  0,                                   /* KeySw_Bgnd */
  0,                                   /* KeepModuleOn */
  0,                                   /* Counter */
  11UL,                                /* EcuAddr_RAM */
  0U,                                  /* CAN1_CANTX_QueueOverrun */
  0U,                                  /* CAN1_CANTX_QueueCount */
  0U,                                  /* CAN1_CANTX_QueueMax */
  0U,                                  /* CAN1_CANRX_QueueOverrun */
  0U,                                  /* CAN1_CANRX_QueueCount */
  0U,                                  /* CAN1_CANRX_QueueMax */
  0U,                                  /* EEPROM_State */
};

#define STOP_SECTION_Const_oem_32bit
#include "swsh_rb2oem.h"

void initRAMVariables(RAMVariables_T* ramVariables)
{
  memcpy(ramVariables, &RAMVariables_DEFAULT, sizeof(RAMVariables_DEFAULT));
}

#define START_SECTION_Const_oem_32bit
#include "swsh_rb2oem.h"

const CONSTVariables_T CONSTVariables = {
  { 82U, 101U, 104U, 97U, 95U, 82U, 97U, 112U, 48U, 49U, },/* ModelName */
  3UL,                                 /* BuildNumber */

  { 40U, 82U, 50U, 48U, 50U, 49U, 98U, 41U, 32U, 57U, 46U, 49U, 49U, },/* MatlabVersion */

  { 50U, 48U, 50U, 49U, 98U, 95U, 49U, 46U, 48U, 46U, 49U, 52U, 52U, 48U, 57U,
    95U, 54U, 49U, 49U, 53U, },        /* RaptorVersion */

  { 82U, 101U, 104U, 97U, 95U, 82U, 97U, 112U, 48U, 49U, 95U, 48U, 48U, 51U, },/* SwIdTxt */

  { 82U, 101U, 104U, 97U, 95U, 82U, 97U, 112U, 48U, 49U, 95U, 48U, 48U, 51U, 95U,
    48U, 48U, 48U, },                  /* CalIdTxt */

  { 87U, 95U, 88U, 78U, 109U, 98U, 115U, 78U, 107U, 85U, 105U, 68U, 70U, 99U,
    77U, 72U, 65U, 84U, 99U, 118U, 103U, },/* BuildUID */
  3,                                   /* IdTableRev */
  2954298117UL,                        /* HardwareType */

  { 48U, 56U, 45U, 83U, 101U, 112U, 45U, 50U, 48U, 50U, 50U, 32U, 49U, 54U, 58U,
    49U, 54U, 58U, 48U, 50U, },        /* DateStamp */
};

#define STOP_SECTION_Const_oem_32bit
#include "swsh_rb2oem.h"

void initCONSTVariables(const CONSTVariables_T* cv)
{

#ifdef UNUSED

  UNUSED(cv);

#endif

}

/* Total EEPROM Structure Size: 34U Bytes */
#define START_SECTION_Const_oem_32bit
#include "swsh_rb2oem.h"

const EEVariables_T EEVariables_DEFAULT = {
  0,                                  /* Write Count: Identifies active Copy 	*/
  3219410521U,                         /* EE_UniqID 	*/
  0.2F,                                /* KeySwHiTimeThr */
  0.2F,                                /* KeySwLoTimeThr */
  256UL,                               /* CAN1__XCP_BC_ID */
  512UL,                               /* CAN1__XCP_RX_ID */
  768UL,                               /* CAN1__XCP_TX_ID */
  20037U,                              /* CAN1__XCP_Security */
  500U,                                /* CAN1_Startup_Delay */
  20U,                                 /* CAN1_ErrorCheck_Interval */
  20U,                                 /* CAN1_ErrorPassive_Delay */
  1U,                                  /* InjCDrv_EndOfStart */
  1U,                                  /* EndOfStart */
  0,                                   /* CRC Initial Value */
};

#define STOP_SECTION_Const_oem_32bit
#include "swsh_rb2oem.h"
#define START_SECTION_volatile_SlowRam_oem_32bit
#include "swsh_rb2oem.h"

EEVariables_T EEVariables_RAMShadow ;

#define STOP_SECTION_volatile_SlowRam_oem_32bit
#include "swsh_rb2oem.h"

uint32_T g_EE_LoadedCopy = 0;

#define FEE_NUM_PAGES                  18

uint16_T read_eeprom(void);

#define EE_PAGE_SIZE                   120
#define FEE_MAX_NUM_PAGES              18
#define FEE_SIZE_CALC()                (((uint32_T)&FEEVariables_RAMShadow.CRC - (uint32_T)&FEEVariables_RAMShadow) + 2)
#define EE_SIZE_CALC()                 (((uint32_T)&EEVariables_RAMShadow.CRC - (uint32_T)&EEVariables_RAMShadow) + 2)
#define RETRY_MAX                      1000

bool g_feeWrite_Started = 0;

/* MANAGE EE PROM MEMORY */
void App_EE_Defaults(void)
{
  memcpy(&EEVariables_RAMShadow, &EEVariables_DEFAULT, sizeof(EEVariables_T));
  EEPROM_State_Data() = EE_LOADED_DEFAULTS;
}

void App_EE_Init(void);
void App_EE_Init(void)
{
  uint8_T firstStart= 0;
  uint32_T ee_size = EE_SIZE_CALC();
  if ((Reset_xHistBuf[0] == SWRESET_CBPROG_E) || ((Reset_xHistBuf[0] ==
        SWRESET_POWERON_SIMU_E) && (Reset_xHistBuf[1] == SWRESET_CBPROG_E))) {
    /* SWRESET_CBPROG_E */
    /* SWRESET_POWERON_SIMU_E, SWRESET_CBPROG_E */
    firstStart = (Reset_Env.xGrp == 0x06);
  } else if ((Reset_xHistBuf[0] == RESET_SWRESET_MOCRAM_REPEXOK) &&
             (Reset_xHistBuf[1] == SWRESET_POWERON_SIMU_E) && (Reset_xHistBuf[2]
              == SWRESET_CBPROG_E)) {
    /*RESET_SWRESET_MOCRAM_REPEXOK, SWRESET_POWERON_SIMU_E, SWRESET_CBPROG_E */
    firstStart = (Reset_Env.xGrp == 0x07);
  }

  /* Fixed NV Read */
  if (firstStart) {
    /* Load defaults after programming - new values may have been merged into EEVariables_DEFAULT */
    App_EE_Defaults();
    EEPROM_State_Data() = EE_LOADED_DEFAULTS_AFTER_PROGRAMMING;
  } else if (read_eeprom() != SWS_EEP_SUCCEEDED) {
    /* Revert to defaults - error reading stored data */
    App_EE_Defaults();
    EEPROM_State_Data() = EE_LOADED_DEFAULTS_ERROR_READING;
  } else if (EEVariables_RAMShadow.EE_UniqID != EEVariables_DEFAULT.EE_UniqID) {
    /* Revert to defaults - the data stored previously doesn't match the format for the current application */
    App_EE_Defaults();
    EEPROM_State_Data() = EE_LOADED_DEFAULTS_INCORRECT_EEID;
  } else if (!is_crc_valid((void*)&EEVariables_RAMShadow, ee_size-2,
              EEVariables_RAMShadow.CRC)) {
    /* Revert to defaults - stored data is corrupted */
    App_EE_Defaults();
    EEPROM_State_Data() = EE_LOADED_DEFAULTS_INCORRECT_CRC;
  } else {
    /* Normal case startup, reloaded values */
    EEPROM_State_Data() = EE_LOADED_SAVED_VALUES;
                                      /* Normal case startup, reloaded values */
  }
}

void App_EE_Store(void)
{
}

/* Extra Funcitons Definitions for EEPROM */
uint16_T read_eeprom(void)
{
  swsEEP_ret result;
  uint16_T eeReadIdx = 20;
  uint8_T readBuf[120];
  uint8_T retryCnt = 0;
  uint8_T* wrPtr = (uint8_T*)&EEVariables_RAMShadow;
  uint32_T ee_size = EE_SIZE_CALC();
  uint16_T total_EE_PgCnt = (ee_size / EE_PAGE_SIZE) + ((ee_size % EE_PAGE_SIZE)
    > 0);
  uint16_T lastPageIdx = total_EE_PgCnt + 20;
  uint16_T lastFullpageIndx = 0;
  eeReadIdx = 20;
  lastPageIdx = total_EE_PgCnt + eeReadIdx;
  if ((EE_SIZE_CALC() % EE_PAGE_SIZE) == 0) {
    lastFullpageIndx = lastPageIdx;
  } else {
    lastFullpageIndx = lastPageIdx - 1;
  }

  /* READ Full EEPROM */
  for (; eeReadIdx < lastPageIdx; eeReadIdx++) {
    retryCnt = 0;
    for (retryCnt = 0; retryCnt < 25; retryCnt++) {
      result = swsEEP_Read_Directly((void*)&readBuf, eeReadIdx);
      if (result == SWS_EEP_SUCCEEDED) {
        break;
      }
    }

    if (result == SWS_EEP_SUCCEEDED) {
      /* copy into EEVariables_RAMShadow	*/
      if (eeReadIdx < lastFullpageIndx) {
        memcpy(wrPtr, &readBuf, EE_PAGE_SIZE);
        wrPtr += EE_PAGE_SIZE;
      } else {
        uint16_T eeReadSize = (EE_SIZE_CALC() % EE_PAGE_SIZE);
        if (eeReadSize == 0) {
          eeReadSize = EE_PAGE_SIZE;
        }

        memcpy(wrPtr, &readBuf, eeReadSize);
      }
    } else {
      break;
    }
  }

  return result;
}

void App_EE_WriteAsync(uint8_T startWrite)
{
  static uint32_T ee_size = 0;
  static uint16_T total_EE_PgCnt = 0;
  static bool eeWrite_Started = 0;
  static uint16_T eeWrite_RetryCnt = 0;
  static uint8_T* eeWrite_Ptr;
  static uint16_T eeWrite_Idx = 20;
  static uint16_T runningCRC = 0xFFFF;
  static uint32_T ee_WriteLen = 0;
  static uint16_T lastPageIdx = 0;
  static uint8_T writeBuffer[EE_PAGE_SIZE] = { 0 };

  swsEEP_ret result;

  //only execute if we are starting a write or already have one in progress
  if (!startWrite && !eeWrite_Started) {
    return;
  }

  if (!eeWrite_Started) {
    eeWrite_RetryCnt = 0;
    eeWrite_Ptr = (void*)&EEVariables_RAMShadow;
    EEPROM_State_Data() = EE_STORE_IN_PROGESS;
    ee_size = EE_SIZE_CALC();
    total_EE_PgCnt = (ee_size / EE_PAGE_SIZE) + ((ee_size % EE_PAGE_SIZE) > 0);
    eeWrite_Started = 1;
    eeWrite_Idx = 20;
    ee_WriteLen = EE_PAGE_SIZE;
    lastPageIdx = total_EE_PgCnt + eeWrite_Idx - 1;
    runningCRC = 0xFFFF;
    if (total_EE_PgCnt == 1) {
      SuspInt();                     //suspend interrupts while we calculate CRC

      //and copy to write buffer so data is not modified elsewhere

      //EE is a single page
      ee_WriteLen = ee_size;
      runningCRC = crc16_spd((void*)&EEVariables_RAMShadow, ee_WriteLen-2,
        runningCRC);
      EEVariables_RAMShadow.CRC = runningCRC;
      memcpy((void*)&writeBuffer, eeWrite_Ptr, ee_WriteLen);
      ResInt();
    } else {
      memcpy((void*)&writeBuffer, eeWrite_Ptr, ee_WriteLen);
      runningCRC = crc16_spd((void*)&writeBuffer, ee_WriteLen, runningCRC);
    }

    // Write the first set of pages to the queue
    result = swsEEP_Write_Directly((void*)&writeBuffer, eeWrite_Idx);
  } else {
    // Check status of previous page writes
    result = swsEEP_Write_Directly((void*)&writeBuffer, eeWrite_Idx);
    if (result == SWS_EEP_SUCCEEDED) {
      //Success
      eeWrite_RetryCnt = 0;
      eeWrite_Idx++;
      eeWrite_Ptr += EE_PAGE_SIZE;
      if (eeWrite_Idx == lastPageIdx ) {
        //last page, update crc
        SuspInt();                   //suspend interrupts while we calculate CRC

        //and copy to write buffer so data is not modified elsewhere
        ee_WriteLen = ee_size % EE_PAGE_SIZE;
        if (ee_WriteLen == 0) {
          ee_WriteLen = EE_PAGE_SIZE;
        }

        runningCRC = crc16_spd((void*)eeWrite_Ptr, ee_WriteLen-2, runningCRC);
        EEVariables_RAMShadow.CRC = runningCRC;
        memcpy((void*)&writeBuffer, (void*)eeWrite_Ptr, ee_WriteLen);
        ResInt();
      } else if (eeWrite_Idx < lastPageIdx) {
        memcpy((void*)&writeBuffer, eeWrite_Ptr, ee_WriteLen);
        runningCRC = crc16_spd((void*)&writeBuffer, ee_WriteLen, runningCRC);
      }

      /* Queue up the write operatation */
      if (eeWrite_Idx <= lastPageIdx) {
        // write new page
        result = swsEEP_Write_Directly((void*)&writeBuffer, eeWrite_Idx);
      } else {
        //finished
        eeWrite_Started = 0;
        EEPROM_State_Data() = EE_STORE_SUCCESS;
      }
    } else if (eeWrite_RetryCnt < RETRY_MAX) {
      //we will check next time
      eeWrite_RetryCnt++;
    } else {
      //Abort Operation
      EEPROM_State_Data() = EE_STORE_FAILED;
      eeWrite_Started = 0;
    }
  }
}
